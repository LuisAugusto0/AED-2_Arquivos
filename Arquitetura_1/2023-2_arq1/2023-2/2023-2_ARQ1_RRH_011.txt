PUC-Minas - ICEI - Ciência da Computação
Arquitetura de Computadores I - Aula 2023-2_012
Anotações
___

Resumo da semana

Máquina de Estados Finitos (FSM - Finite State Machine)
ou
Autômatos Finitos


Tipos

- detectores/reconhecedores ({0:1} ou {false:true}}
- transdutores: Mealy, Moore
- classificadores           ({a,b,c,d,e})
- sequenciadores/geradores

___

Exemplo: Reconhecedor de sequência 1101

1. FSM
                    FSM Diagram                                          
                                       [final]
					 ^
                                         | 1:1
           1:0        1:0         0:0    | // found
   [start] ---> [id1] ---> [id11] ---> [id110]
     ^  \0:0   0:0|      1:0 / ^         | // not found
      \_/        /           \__/        | 0:0
       \________/                       /
        \                              /
         \____________________________/

   estado  entrada             estado  entrada
           0     1                     0     1
    >q0    q0    q1             *000   000   001
     q1    q0    q2              001   000   010
     q2    q3    q2              010   011   010
     q3    q0    q4#             011   000   100+

   Matriz de estados/transições
   
   atual\próximo
         q0 q1 q2 q3 q4
     q0   0  1         
     q1   0     1      
     q2         1  0   
     q3   0          1      
     q4              + 
     

   Algoritmo ( "C-like" )

   // value = MUX (op0, op1, select)

   const int
         notfound=0, found=1;
   const int 
         start=0, id1=1, id11=2, id110=3, final=4;

   int   E1 = start;   // initial state
   int   E2 = start;   // next    state
   int   x  = 0;
   int   y  = 0;

   do
   { 
     x = get_input( );
     y = notfound;     // prepare output
     switch ( E1 )
     {
      case start: E2 = MUX ( start   , id1  , x ); break;
      case id1  : E2 = MUX ( start   , id11 , x ); break;
      case id11 : E2 = MUX ( id110   , id11 , x ); break;
      case id110: E2 = MUX ( start   , final, x ); 
	           y = MUX ( notfound, found, x ); break;
      default   : E2 = final; /* error */          break;
     }
     E1 = E2;          // updates current state
    } 
    while  ( E1 != final ); // always at signal or state changing
    print_output ( y );
     
2. Mealy 
                Mealy FSM Diagram
                   _____________________
                  /                     \  1:1
           1:0    v   1:0         0:0    | // found
   [start] ---> [id1] ---> [id11] ---> [id110]
     ^  \0:0   0:0|      1:0 / ^         | // not found
      \_/        /           \__/        | 0:0
       \________/                       /
        \                              /
         \____________________________/

   estado  entrada; saída       estado entrada; saída
           0     1                     0     1
    >q0    q0;0  q1;0           *000   000 0 001 0
     q1    q0;0  q2;0            001   000 0 010 0
     q2    q3;0  q2;0            010   011 0 010 0
     q3    q0;0  q4;1            011   000 0 100 1
                                           ^     ^
    bit separado = saída __________________|_____|
 
   Matriz de estados/transições (entrada; saída)
   
   atual\próximo
         q0   q1  q2  q3  q4 
     q0  0;0  1;0            
     q1  1;0      0;0        
     q2           1;0 0;0    
     q3  0;0              1;1
     q4                   + 


   Algoritmo ( "C-like" )

   // value = MUX (op0, op1, select)

   const int
         notfound=0, found=1;
   const int 
         start=0, id1=1, id11=2, id110=3, final=4;

   int   E1 = start;   // initial state
   int   E2 = start;   // next    state
   int   x  = 0;
   int   y  = 0;

   do
   { 
     x = get_input( );
     y = notfound;     // prepare output
     switch ( E1 )
     {
      case start: E2 = MUX ( start   , id1  , x ); break;
      case id1  : E2 = MUX ( start   , id11 , x ); break;
      case id11 : E2 = MUX ( id110   , id11 , x ); break;
      case id110: E2 = MUX ( start   , id1  , x ); 
	           y = MUX ( notfound, found, x ); break;
      default   : E2 = final; /* error */          break;
     }
     E1 = E2;          // updates current state
     print_output ( y );
    } 
    while  ( E1 != final ); // always at signal or state changing
     
3. Moore 
                       Moore FSM Diagram
		               _______________________
                              /                       \  1
            1     v    1     v     0            1     | // found
   [start] ---> [id1] ---> [id11] ---> [id110] ---> [id1101]
     ^  \0      0 |        1/ ^        0 |            | 0
      \_/        /          \__/         |            |
       \________/                       /             |
        \                              /             /
         \____________________________/             /
          \                                        /
           \______________________________________/


   estado  entrada;saída       estado  [saída]entrada
           0     1                        0      1
    *q0    q0;0  q1;0          *0000   [0]000 [0]001
     q1    q0;0  q2;0           0001   [0]000 [0]010
     q2    q3;0  q2;0           0010   [0]011 [0]010
     q3    q0;0  q4;0           0011   [0]000 [1]100
     q4    q4;1  q4;1           1100   [1]100 [1]100
                                ^       ^      ^
     primeiro bit = saída ______|_______|______|

   Matriz de estados/transições
   
   atual\próximo
         q0   q1  q2  q3  q4 
     q0  0;0  1;0            
     q1  1;0      0;0        
     q2           1;0 0;0    
     q3  0;0              1;0
     q4                   _;1+ 


   Algoritmo ( "C-like" )

   // value = MUX (op0, op1, select)

   const int
         notfound=0, found=1;
   const int 
         start=0, id1=1, id11=2, id110=3, id1101=12, final=5;

   int   E1 = start;   // initial state
   int   E2 = start;   // next    state
   int   x  = 0;
   int   y  = 0;

   do
   { 
     x = get_input( );
     y = notfound;     // prepare output
     switch ( E1 )
     {
      case start : E2 = MUX ( start   , id1   , x ); break;
      case id1   : E2 = MUX ( start   , id11  , x ); break;
      case id11  : E2 = MUX ( id110   , id11  , x ); break;
      case id110 : E2 = MUX ( start   , id1101, x ); break;
      case id1101: E2 = MUX ( start   , id11  , x );  
                   //   saida = priimeiro bit ([1]100)
	            y = (E2&8)/8;                    break;
      default    : E2 = final; /* error */           break;
     }
     E1 = E2;          // updates current state
    } 
    while  ( E1 != final ); // always at signal or state changing
    print_output ( y );
     
